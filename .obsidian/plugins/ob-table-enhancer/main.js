/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/table-editor.ts
var import_obsidian = require("obsidian");

// src/editor-utils.ts
var hashCode = function(input, seed = 0) {
  let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  for (let i = 0, ch; i < input.length; i++) {
    ch = input.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return 4294967296 * (2097151 & h2) + (h1 >>> 0);
};
var getLineStartPos = (line) => ({
  line,
  ch: 0
});
var getLineEndPos = (line, editor) => ({
  line,
  ch: editor.getLine(line).length
});
var deleteLines = (editor, from, to) => {
  if (to === editor.lastLine() + 1) {
    editor.replaceRange("", getLineEndPos(from - 1, editor), getLineEndPos(to, editor));
  } else {
    editor.replaceRange("", getLineStartPos(from), getLineStartPos(to));
  }
};
var deleteLine = (editor, line) => {
  deleteLines(editor, line, line + 1);
};
var getLeadingWhitespace = (lineContent) => {
  const indentation = lineContent.match(/^\s+/);
  return indentation ? indentation[0] : "";
};
var insertLineBelow = (editor, line) => {
  const endOfCurrentLine = getLineEndPos(line, editor);
  const indentation = getLeadingWhitespace(editor.getLine(line));
  editor.replaceRange("\n" + indentation, endOfCurrentLine);
  return { anchor: { line: line + 1, ch: indentation.length } };
};
var insertLineBelowWithText = (editor, line, text) => {
  const endOfCurrentLine = getLineEndPos(line, editor);
  const indentation = getLeadingWhitespace(editor.getLine(line));
  const textToInsert = text.split(/\r?\n/).map((s) => indentation + s).join("\n");
  editor.replaceRange("\n" + textToInsert, endOfCurrentLine);
  return { anchor: { line: line + 1, ch: indentation.length } };
};

// src/table-editor.ts
var TableEditor = class {
  constructor(app) {
    this.app = app;
  }
  async parseActiveFile() {
    this.activeFile = this.app.workspace.getActiveFile();
    if (!this.activeFile)
      return;
    this.tables = /* @__PURE__ */ new Map();
    const fullText = await this.app.vault.read(this.activeFile);
    this.rows = fullText.split(/\r?\n/);
    const formatRowRegex = /^\s*(\|?)(?:[:\-\s|\u00A0\u1680\u180E\u2000-\u200B\u202F\u205F\u3000\uFEFF]+)+$/;
    const len = this.rows.length;
    let existNonStandardTable = false;
    for (let i = 0; i < len; i++) {
      const row = this.rows[i];
      if (row.startsWith("---"))
        continue;
      const matchResult = row.match(formatRowRegex);
      if (matchResult) {
        if (i - 1 < 0)
          continue;
        if (!matchResult[1]) {
          existNonStandardTable = true;
          await this.standardize(i);
          i = i - 1;
          continue;
        }
        const table = {
          fromRowIndex: i - 1,
          toRowIndex: i,
          formatRow: this.rows[i].split("|").slice(1, -1),
          cells: []
        };
        const rowAbove = this.rows[i - 1];
        table.cells.push(rowAbove.split("|").slice(1, -1));
        while (++i < len) {
          const bodyRow = this.rows[i];
          if (bodyRow.trimStart().startsWith("|"))
            table.cells.push(bodyRow.split("|").slice(1, -1));
          else
            break;
        }
        table.toRowIndex = i;
        this.tables.set(TableEditor.getIdentifier(table), table);
      }
    }
    if (existNonStandardTable) {
      const fullTextAfterStandardize = this.rows.join("\n");
      await this.app.vault.modify(this.activeFile, fullTextAfterStandardize);
    }
  }
  async standardize(formatRowIndex) {
    this.rows[formatRowIndex - 1] = ["|", this.rows[formatRowIndex - 1], "|"].join("");
    this.rows[formatRowIndex] = ["|", this.rows[formatRowIndex], "|"].join("");
    let i = formatRowIndex;
    const len = this.rows.length;
    while (++i < len) {
      const bodyRow = this.rows[i];
      if (bodyRow.match(/^\s*[^|]*\|/)) {
        this.rows[i] = ["|", this.rows[i], "|"].join("");
      } else
        break;
    }
  }
  getCell(tableId, rowIndex, colIndex) {
    try {
      return this.tables.get(tableId).cells[rowIndex][colIndex].trim();
    } catch (e) {
      return "";
    }
  }
  getLineNumber(table, rowIndex) {
    return table.fromRowIndex + (rowIndex == 0 ? rowIndex : rowIndex + 1);
  }
  async update(tableId, rowIndex, colIndex, newContent) {
    const table = this.tables.get(tableId);
    if (!table)
      return;
    table.cells[rowIndex][colIndex] = newContent;
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (markdownView instanceof import_obsidian.MarkdownView) {
      const editor = markdownView.editor;
      const rowLineNumber = this.getLineNumber(table, rowIndex);
      const newLine = TableEditor.rowCells2rowString(table.cells[rowIndex]);
      if (editor.getLine(rowLineNumber).length == newLine.length)
        editor.setLine(rowLineNumber, newLine + " ");
      editor.setLine(rowLineNumber, newLine);
      await markdownView.save();
    }
  }
  async deleteRow(tableId, rowIndex) {
    const table = this.tables.get(tableId);
    if (!table)
      return;
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (rowIndex == 0) {
      return;
    }
    const rowLineNumber = this.getLineNumber(table, rowIndex);
    if (markdownView instanceof import_obsidian.MarkdownView) {
      const editor = markdownView.editor;
      deleteLine(editor, rowLineNumber);
      await markdownView.save();
    }
  }
  async deleteCol(tableId, colIndex) {
    const table = this.tables.get(tableId);
    if (!table)
      return;
    table.formatRow.splice(colIndex, 1);
    for (const row of table.cells)
      row.splice(colIndex, 1);
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (markdownView instanceof import_obsidian.MarkdownView) {
      const editor = markdownView.editor;
      if (table.formatRow.length == 1) {
        deleteLines(editor, table.fromRowIndex, table.toRowIndex);
      } else {
        editor.setLine(table.fromRowIndex + 1, TableEditor.rowCells2rowString(table.formatRow));
        for (let i = 0; i < table.cells.length; i++) {
          const lineNumber = this.getLineNumber(table, i);
          editor.setLine(lineNumber, TableEditor.rowCells2rowString(table.cells[i]));
        }
      }
      await markdownView.save();
    }
  }
  async insertColRight(tableId, colIndex) {
    const table = this.tables.get(tableId);
    if (!table)
      return;
    table.formatRow.splice(colIndex + 1, 0, "---");
    for (const row of table.cells)
      row.splice(colIndex + 1, 0, "   ");
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (markdownView instanceof import_obsidian.MarkdownView) {
      const editor = markdownView.editor;
      editor.setLine(table.fromRowIndex + 1, TableEditor.rowCells2rowString(table.formatRow));
      for (let i = 0; i < table.cells.length; i++) {
        const lineNumber = this.getLineNumber(table, i);
        editor.setLine(lineNumber, TableEditor.rowCells2rowString(table.cells[i]));
      }
      await markdownView.save();
    }
  }
  async insertRowBelow(tableId, rowIndex) {
    const table = this.tables.get(tableId);
    if (!table)
      return;
    if (rowIndex == 0) {
      return;
    }
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (markdownView instanceof import_obsidian.MarkdownView) {
      const editor = markdownView.editor;
      const row = [];
      let i = table.formatRow.length;
      while (i--) {
        row.push("  ");
      }
      const rowText = TableEditor.rowCells2rowString(row);
      const rowLineNumber = this.getLineNumber(table, rowIndex);
      insertLineBelow(editor, rowLineNumber);
      editor.setLine(rowLineNumber + 1, rowText);
      await markdownView.save();
    }
  }
  async createMinimalNewTable() {
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (markdownView instanceof import_obsidian.MarkdownView) {
      const editor = markdownView.editor;
      const rowIndex = editor.getCursor().line;
      if (this.tables)
        for (const table of this.tables.values()) {
          if (table.fromRowIndex <= rowIndex && rowIndex <= table.toRowIndex) {
            new import_obsidian.Notice("Can't create table within another table.");
            return;
          }
        }
      const text = "| Col 1 | Col 2 |\n|---|---|\n| xxxx | xxxx |\n";
      insertLineBelowWithText(editor, rowIndex, text);
      await markdownView.save();
    }
  }
  static getIdentifier(table) {
    const result = [];
    const rowNum = table.cells.length;
    for (let i2 = 0; i2 < rowNum; i2++) {
      const str = table.cells[i2][0];
      if (str && str.trim() != "" && !str.match(/[!<>*#\[\]`$=]/))
        result.push(str.trim());
    }
    let i = table.cells[0].length;
    while (i--) {
      const str = table.cells[0][i];
      if (str && str.trim() != "" && !str.match(/[!<>*#\[\]`$=]/))
        result.push(str.trim());
    }
    const resultStr = result.join("");
    return String.fromCharCode(hashCode(resultStr));
  }
  static rowCells2rowString(cells) {
    const result = ["|"];
    for (const cell of cells) {
      result.push(cell);
      result.push("|");
    }
    return result.join("");
  }
};

// src/html-utils.ts
function getCaretPosition(editableElem) {
  let caretPos = 0, sel, range;
  sel = activeWindow.getSelection();
  if (sel && sel.rangeCount) {
    range = sel.getRangeAt(0);
    if (range.commonAncestorContainer.parentNode == editableElem) {
      caretPos = range.endOffset;
    }
  }
  return caretPos;
}
function setCaretPosition(editableElem, newPos) {
  let caretPos = 0, sel, range = activeDocument.createRange();
  sel = activeWindow.getSelection();
  if (sel && sel.rangeCount) {
    range.setStart(editableElem.childNodes[0], newPos);
    range.collapse(true);
    sel.removeAllRanges();
    sel.addRange(range);
  }
  return caretPos;
}
function getCaretRect(container) {
  let caretPos = 0, sel, range;
  sel = activeWindow.getSelection();
  if (sel && sel.rangeCount) {
    range = sel.getRangeAt(0);
    const rect = range.getBoundingClientRect();
    return rect;
  }
  return null;
}

// src/table-utils.ts
function isSameCell(c1, c2) {
  if (!c1 || !c2)
    return false;
  return c1.tableId == c2.tableId && c1.rowIndex == c2.rowIndex && c1.colIndex == c2.colIndex;
}

// src/reference-suggest.ts
var import_obsidian2 = require("obsidian");
var SuggestionPopper = class {
  constructor(app) {
    this.onTrigger = (queryPattern) => {
      if (!this.candidates)
        this.onUpdateCandidates();
      this.isTriggered = true;
      activeDocument.body.appendChild(this.containerEl);
      this.suggestionEl.innerHTML = "";
      const fuzzySearchFunc = (0, import_obsidian2.prepareFuzzySearch)(queryPattern);
      this.fuzzySuggestions = this.candidates.map((c, i) => {
        const queryString = this.getQueryString(c);
        const searchResult = fuzzySearchFunc.call(null, queryString);
        return searchResult ? {
          display: this.getDisplay(c, queryString, searchResult),
          replaceString: this.getReplaceString(c),
          matched: searchResult.matched,
          score: searchResult.score
        } : null;
      }).filter((o) => o != null).sort((e1, e2) => e2.score - e1.score);
      const caretRect = getCaretRect(this.containerEl);
      const outerRect = this.outerEl.getBoundingClientRect();
      this.containerEl.style.left = `${caretRect.left}px`;
      this.containerEl.style.top = `${caretRect.top + outerRect.height}px`;
      this.containerEl.style.display = "block";
      this.fuzzySuggestions.map((suggestion, i) => {
        this.suggestionEl.createDiv({ cls: "suggestion-item mod-complex" }, (div) => {
          div.innerHTML = suggestion.display;
          div.onmouseover = (e) => this.select(i);
          div.onclick = (e) => this.applySuggestion();
        });
      });
      this.selectedIndex = -1;
    };
    this.selectNext = () => {
      var _a;
      const len = this.suggestionEl.children.length;
      (_a = this.suggestionEl.children[this.selectedIndex]) == null ? void 0 : _a.classList.remove("is-selected");
      if (this.selectedIndex >= len - 1)
        this.selectedIndex = 0;
      else
        this.selectedIndex++;
      const selectedElem = this.suggestionEl.children[this.selectedIndex];
      selectedElem.classList.add("is-selected");
      selectedElem.scrollIntoView(false);
    };
    this.selectPrev = () => {
      var _a;
      const len = this.suggestionEl.children.length;
      (_a = this.suggestionEl.children[this.selectedIndex]) == null ? void 0 : _a.classList.remove("is-selected");
      if (this.selectedIndex <= 0)
        this.selectedIndex = len - 1;
      else
        this.selectedIndex--;
      const selectedElem = this.suggestionEl.children[this.selectedIndex];
      selectedElem.classList.add("is-selected");
      selectedElem.scrollIntoView(false);
    };
    this.select = (selectIndex) => {
      var _a;
      (_a = this.suggestionEl.children[this.selectedIndex]) == null ? void 0 : _a.classList.remove("is-selected");
      this.selectedIndex = selectIndex;
      const selectedElem = this.suggestionEl.children[this.selectedIndex];
      selectedElem.classList.add("is-selected");
      selectedElem.scrollIntoView(false);
    };
    this.applySuggestion = () => {
      const selectSuggestion = this.fuzzySuggestions[this.selectedIndex];
      const caretPosition = getCaretPosition(this.outerEl);
      const beg2caret = this.outerEl.innerText.slice(0, caretPosition);
      const caret2end = this.outerEl.innerText.slice(caretPosition + 1);
      const afterApply = beg2caret.replace(/\[\[([^\[\]]*)$/, selectSuggestion.replaceString);
      this.outerEl.innerHTML = [afterApply, caret2end].join("");
      setCaretPosition(this.outerEl, afterApply.length);
      this.disable();
      return;
    };
    this.app = app;
    this.containerEl = createDiv({ cls: "ob-table-enhancer suggestion-container" });
    this.suggestionEl = this.containerEl.createDiv({ cls: "ob-table-enhancer suggestion" });
  }
  disable() {
    this.isTriggered = false;
    this.containerEl.detach();
  }
  bindOuterEl(outerEl) {
    this.outerEl = outerEl;
    this.trigger();
    const oldKeydown = this.outerEl.onkeydown;
    this.outerEl.onkeydown = (e) => {
      if (this.isTriggered) {
        if (e.key == "ArrowUp") {
          e.preventDefault();
          e.stopPropagation();
          this.selectPrev();
          return;
        }
        if (e.key == "ArrowDown") {
          e.preventDefault();
          e.stopPropagation();
          this.selectNext();
          return;
        }
        if (e.key == "Enter") {
          e.preventDefault();
          e.stopPropagation();
          this.applySuggestion();
          return;
        }
      }
      if (oldKeydown) {
        oldKeydown(e);
      }
    };
  }
};
var ReferenceSuggestionPopper = class extends SuggestionPopper {
  getDisplay(item, queryString, searchResult) {
    let i = 0;
    const result = [];
    result.push('<div class="suggestion-content">');
    result.push('<div class="suggestion-title">');
    for (const [j1, j2] of searchResult.matches) {
      result.push("<span>");
      result.push(queryString.slice(i, j1));
      result.push("</span>");
      result.push('<span class="suggestion-highlight">');
      result.push(queryString.slice(j1, j2));
      result.push("</span>");
      i = j2;
    }
    result.push("<span>");
    result.push(queryString.slice(i));
    result.push("</span>");
    result.push("</div>");
    if (item.parent.path != "") {
      result.push('<div class="suggestion-note">');
      result.push(item.parent.path);
      result.push("</div>");
    }
    result.push("</div>");
    return result.join("");
  }
  getQueryString(item) {
    return item.basename;
  }
  getReplaceString(item) {
    const activeFile = this.app.workspace.getActiveFile();
    return this.app.fileManager.generateMarkdownLink(item, activeFile.path);
  }
  trigger() {
    const oldInput = this.outerEl.oninput;
    this.outerEl.oninput = (e) => {
      const caretPosition = getCaretPosition(this.outerEl);
      const text = this.outerEl.innerText.slice(0, caretPosition);
      const matchResult = text.match(/\[\[([^\[\]]*)$/);
      if (matchResult) {
        this.onTrigger(matchResult[1]);
      } else {
        this.containerEl.style.display = "none";
      }
      if (oldInput) {
        oldInput(e);
      }
    };
  }
  updateCandidates() {
    this.app.metadataCache.on("resolved", () => {
      this.onUpdateCandidates();
    });
  }
  onUpdateCandidates() {
    this.candidates = this.app.vault.getMarkdownFiles();
  }
};

// main.ts
var MyPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    this.tableEditor = new TableEditor(this.app);
    this.editingCell = null;
    this.app.workspace.onLayoutReady(() => {
      this.suggestPopper = new ReferenceSuggestionPopper(this.app);
      activeDocument.addEventListener("keydown", async (e) => {
        if (!this.editingCell)
          return;
        const cell = this.editingCell.cell;
        if (!e.repeat && e.key == "Enter" && e.shiftKey && this.editingCell) {
          cell.innerText = cell.innerText + "<br>";
          return;
        }
        if (!e.repeat && (e.key == "Enter" || e.key == "Escape")) {
          e.preventDefault();
          await this.doneEdit(this.editingCell);
          return;
        }
        if (e.key == "ArrowLeft") {
          e.preventDefault();
          e.stopPropagation();
          const caretPos = getCaretPosition(cell);
          const { tableId, rowIndex, colIndex } = this.editingCell;
          if (caretPos == 0) {
            await this.doneEdit(this.editingCell);
            const cellLeft = activeDocument.querySelector(`#${tableId}${rowIndex}${colIndex - 1}`);
            if (cellLeft instanceof HTMLTableCellElement) {
              cellLeft.click();
            }
          } else {
            setCaretPosition(cell, caretPos - 1);
          }
          return;
        }
        if (e.key == "ArrowRight") {
          e.preventDefault();
          e.stopPropagation();
          const caretPos = getCaretPosition(cell);
          const { tableId, rowIndex, colIndex } = this.editingCell;
          if (caretPos == cell.innerText.length) {
            await this.doneEdit(this.editingCell);
            const cellRight = activeDocument.querySelector(`#${tableId}${rowIndex}${colIndex + 1}`);
            if (cellRight instanceof HTMLTableCellElement) {
              cellRight.click();
            }
          } else {
            setCaretPosition(cell, caretPos + 1);
          }
          return;
        }
        if (!e.repeat && e.ctrlKey && e.key == "a") {
          e.preventDefault();
          e.stopPropagation();
          const selection = activeWindow.getSelection();
          const range = activeDocument.createRange();
          range.selectNodeContents(cell);
          selection == null ? void 0 : selection.removeAllRanges();
          selection == null ? void 0 : selection.addRange(range);
          return;
        }
        if (e.key == "ArrowUp") {
          e.preventDefault();
          e.stopPropagation();
          const { tableId, rowIndex, colIndex } = this.editingCell;
          await this.doneEdit(this.editingCell);
          const cellAbove = activeDocument.querySelector(`#${tableId}${rowIndex - 1}${colIndex}`);
          if (cellAbove instanceof HTMLTableCellElement) {
            cellAbove.click();
          }
          return;
        }
        if (e.key == "ArrowDown") {
          e.preventDefault();
          e.stopPropagation();
          const { tableId, rowIndex, colIndex } = this.editingCell;
          await this.doneEdit(this.editingCell);
          const cellBelow = activeDocument.querySelector(`#${tableId}${rowIndex + 1}${colIndex}`);
          if (cellBelow instanceof HTMLTableCellElement) {
            cellBelow.click();
          }
          return;
        }
        if (e.shiftKey && e.key == "Tab") {
          e.preventDefault();
          e.stopPropagation();
          const { tableId, rowIndex, colIndex } = this.editingCell;
          await this.doneEdit(this.editingCell);
          const cellLeft = activeDocument.querySelector(`#${tableId}${rowIndex}${colIndex - 1}`);
          if (cellLeft instanceof HTMLTableCellElement) {
            cellLeft.click();
          }
          return;
        }
        if (e.key == "Tab") {
          e.preventDefault();
          e.stopPropagation();
          const { tableId, rowIndex, colIndex } = this.editingCell;
          await this.doneEdit(this.editingCell);
          const cellRight = activeDocument.querySelector(`#${tableId}${rowIndex}${colIndex + 1}`);
          if (cellRight instanceof HTMLTableCellElement) {
            cellRight.click();
          }
          return;
        }
      });
      activeDocument.addEventListener("click", async () => {
        if (this.editingCell && !isSameCell(this.hoverCell, this.editingCell)) {
          await this.doneEdit(this.editingCell);
        }
      });
      this.ctrl = false;
      activeDocument.addEventListener("keydown", (e) => {
        if (e.key == "Ctrl")
          this.ctrl = true;
      });
      activeDocument.addEventListener("keyup", (e) => {
        if (e.key == "Ctrl")
          this.ctrl = false;
      });
    });
    this.registerMarkdownPostProcessor((element, context) => {
      const tables = element.querySelectorAll("table");
      tables.forEach((table) => {
        const tableId = this.getIdentifier(table);
        table.onmouseenter = (e) => this.hoverTableId = tableId;
        table.onclick = (e) => e.preventDefault();
        for (let j = 0; j < table.rows.length; j++) {
          const row = table.rows[j];
          for (let k = 0; k < row.cells.length; k++) {
            const cell = row.cells[k];
            cell.setAttr("id", `${tableId}${j}${k}`);
            cell.onmouseenter = (e) => this.hoverCell = {
              tableId,
              rowIndex: j,
              colIndex: k,
              cell
            };
            cell.onmouseout = (e) => this.hoverCell = null;
            cell.onclick = async (e) => {
              var _a;
              e.preventDefault();
              e.stopPropagation();
              if (this.ctrl)
                return;
              if (cell.getAttr("contenteditable") == "true" || !this.hoverTableId)
                return;
              if (this.editingCell && !isSameCell(this.editingCell, this.hoverCell)) {
                await this.doneEdit(this.editingCell);
                const newCell = activeDocument.querySelector(`#${tableId}${j}${k}`);
                if (newCell instanceof HTMLTableCellElement)
                  newCell.click();
                return;
              }
              await this.tableEditor.parseActiveFile();
              const text = this.tableEditor.getCell(this.hoverTableId, j, k);
              cell.innerText = text;
              cell.setAttr("contenteditable", true);
              cell.focus();
              if (text != "")
                setCaretPosition(cell, text.length);
              cell.style.backgroundColor = "var(--bg1)";
              cell.style.filter = "brightness(1.5)";
              this.editingCell = { tableId: this.hoverTableId, rowIndex: j, colIndex: k, cell };
              (_a = this.suggestPopper) == null ? void 0 : _a.bindOuterEl(cell);
            };
          }
        }
      });
    });
    this.registerEvent(this.app.workspace.on("editor-menu", (menu, editor, view) => {
      menu.addItem((item) => {
        item.setTitle("Create 2x2 table");
        item.onClick(async () => {
          await this.tableEditor.parseActiveFile();
          await this.tableEditor.createMinimalNewTable();
        });
      });
      if (!this.hoverCell || !this.hoverTableId)
        return;
      const hoverCellRowIndex = this.hoverCell.rowIndex;
      const hoverCellColIndex = this.hoverCell.colIndex;
      const hoverTableId = this.hoverTableId;
      menu.addItem((item) => {
        item.setTitle("Delete row");
        item.onClick(async () => {
          if (hoverCellRowIndex == 0) {
            new import_obsidian3.Notice("You can't delete header of a table.");
            return;
          }
          await this.tableEditor.parseActiveFile();
          await this.tableEditor.deleteRow(hoverTableId, hoverCellRowIndex);
        });
      }).addItem((item) => {
        item.setTitle("Delete column");
        item.onClick(async () => {
          await this.tableEditor.parseActiveFile();
          await this.tableEditor.deleteCol(hoverTableId, hoverCellColIndex);
        });
      }).addItem((item) => {
        item.setTitle("Insert row below");
        item.onClick(async () => {
          if (hoverCellRowIndex == 0) {
            new import_obsidian3.Notice("You can't add new row under header of table.");
            return;
          }
          await this.tableEditor.parseActiveFile();
          await this.tableEditor.insertRowBelow(hoverTableId, hoverCellRowIndex);
        });
      }).addItem((item) => {
        item.setTitle("Insert column right (left aligned)");
        item.onClick(async () => {
          await this.tableEditor.parseActiveFile();
          await this.tableEditor.insertColRight(hoverTableId, hoverCellColIndex);
        });
      });
    }));
  }
  onunload() {
  }
  async doneEdit(cell) {
    const { rowIndex, colIndex, cell: cellElem } = cell;
    if (!this.hoverTableId)
      return;
    cellElem.setAttr("contenteditable", false);
    await this.tableEditor.update(this.hoverTableId, rowIndex, colIndex, cellElem.innerText);
    cellElem.style.backgroundColor = "initial";
    cellElem.style.filter = "none";
    this.editingCell = null;
    if (this.suggestPopper)
      this.suggestPopper.disable();
  }
  getIdentifier(table) {
    const result = [];
    const rowNum = table.rows.length;
    for (let i2 = 0; i2 < rowNum; i2++) {
      const str = table.rows[i2].cells[0].innerHTML.replace(/&nbsp;/gi, "");
      if (str && str.trim() != "" && !str.match(/[!<>*#\[\]`$=]/)) {
        result.push(str.trim());
      }
    }
    let i = table.rows[0].cells.length;
    while (i--) {
      const str = table.rows[0].cells[i].innerHTML.replace(/&nbsp;/gi, "");
      if (str && str.trim() != "" && !str.match(/[!<>*#\[\]`$=]/))
        result.push(str.trim());
    }
    const resultStr = result.join("");
    return String.fromCharCode(hashCode(resultStr));
  }
  async forcePostProcessorReload() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      const view = leaf.view;
      if (view.getViewType() === "markdown") {
        if (view instanceof import_obsidian3.MarkdownView)
          view.previewMode.rerender(true);
      }
    });
  }
};
